<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hash-Crash Scheduler: Final Exam Edition</title>
    <style>
        :root {
            --bg-color: #1e1e2e;
            --card-bg: #313244;
            --slot-bg: #45475a;
            --accent: #89b4fa;
            --success: #a6e3a1;
            --error: #f38ba8;
            --text: #cdd6f4;
            --highlight: #f9e2af;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        header { text-align: center; margin: 20px 0; }
        h1 { color: var(--accent); margin-bottom: 5px; font-size: 1.8rem; }
        .subtitle { font-size: 0.9em; opacity: 0.8; }

        #game-container {
            width: 90%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Info Panel */
        #info-panel {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            flex-wrap: wrap;
            gap: 10px;
        }

        #info-panel .info-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #info-panel label {
            font-size: 0.8rem;
            cursor: pointer;
        }

        /* Arcade timer */
        #arcade-timer {
            background: #181825;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.85rem;
        }

        #arcade-timer-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #arcade-timer-bar {
            width: 100%;
            height: 8px;
            background: #313244;
            border-radius: 999px;
            overflow: hidden;
        }

        #arcade-timer-fill {
            width: 100%;
            height: 100%;
            background: var(--accent);
            transform-origin: left center;
            transition: width 0.3s linear;
        }

        /* Current Data Card */
        #current-card-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 120px;
            background: #181825;
            border-radius: 8px;
            border: 2px dashed var(--text);
            margin-bottom: 20px;
        }

        .data-card {
            background: var(--accent);
            color: #111;
            padding: 15px 30px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: popIn 0.3s ease;
            text-align: center;
            min-width: 220px;
        }

        .data-card-main {
            margin-bottom: 4px;
        }

        .data-card-sub {
            font-size: 0.75em;
            font-weight: normal;
            opacity: 0.85;
        }

        .data-card-working {
            font-size: 0.7em;
            background: rgba(0,0,0,0.35);
            margin-top: 6px;
            padding: 3px;
            border-radius: 3px;
        }

        @keyframes popIn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        /* Memory Grid */
        #memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 40px;
        }

        .memory-slot {
            background: var(--slot-bg);
            border: 2px solid #585b70;
            border-radius: 5px;
            min-height: 100px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            outline: none;
        }

        .memory-slot:hover,
        .memory-slot:focus-visible {
            border-color: var(--accent);
            background: #585b70;
            transform: translateY(-2px);
        }

        /* Pulse Feedback */
        .slot-pulse-correct {
            animation: pulse-correct 0.4s ease-out;
        }

        .slot-pulse-wrong {
            animation: pulse-wrong 0.4s ease-out;
        }

        @keyframes pulse-correct {
            0% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(166, 227, 161, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0); }
        }

        @keyframes pulse-wrong {
            0% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(243, 139, 168, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0); }
        }

        /* Probe path highlight */
        .slot-probe-path {
            animation: probe-glow 0.6s ease-out;
        }

        @keyframes probe-glow {
            0% { box-shadow: 0 0 0 0 rgba(137, 180, 250, 0.7); }
            100% { box-shadow: 0 0 0 0 rgba(137, 180, 250, 0); }
        }

        .slot-index {
            font-size: 0.8em;
            color: #9399b2;
            margin-bottom: 5px;
            border-bottom: 1px solid #9399b2;
            width: 100%;
            text-align: center;
        }

        .stored-item {
            background: var(--accent);
            color: #111;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-top: 2px;
            width: 90%;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .linked-arrow {
            color: var(--text);
            font-size: 0.8em;
        }

        /* Feedback Area */
        #feedback {
            text-align: center;
            min-height: 30px;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        /* Modal */
        #modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 650px;
            width: 90%;
            text-align: center;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(137, 180, 250, 0.2);
            max-height: 90vh;
            overflow-y: auto;
        }

        .start-btn {
            background: var(--accent);
            color: #1e1e2e;
            border: none;
            padding: 12px 30px;
            font-size: 1.05em;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: 900;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 12px rgba(137,180,250,0.6);
        }

        .hidden { display: none !important; }

        /* Quiz Styles */
        .quiz-container {
            text-align: left;
            margin-top: 20px;
            max-height: 320px;
            overflow-y: auto;
        }
        .quiz-question {
            font-size: 1.05em;
            margin-bottom: 15px;
            color: var(--highlight);
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .quiz-option {
            background: var(--slot-bg);
            padding: 10px 12px;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #585b70;
            transition: background 0.2s, transform 0.05s;
            font-family: inherit;
            font-size: 0.95em;
            text-align: left;
        }
        .quiz-option:hover:enabled {
            background: #585b70;
            transform: translateY(-1px);
        }
        .quiz-option.correct {
            background: var(--success);
            color: #111;
            border-color: var(--success);
        }
        .quiz-option.wrong {
            background: var(--error);
            color: #111;
            border-color: var(--error);
        }
        .quiz-explanation {
            font-size: 0.85em;
            background: #181825;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid var(--highlight);
        }
        .quiz-next-btn {
            font-size: 0.9em;
            padding: 8px 16px;
            margin-top: 10px;
        }
        .quiz-next-btn:disabled {
            opacity: 0.5;
            cursor: default;
            box-shadow: none;
            transform: none;
        }

        @media (max-width: 600px) {
            .data-card {
                padding: 12px 16px;
                font-size: 1em;
            }
            #info-panel {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>The Hash-Crash Scheduler</h1>
        <div class="subtitle">AQA A-Level Computer Science: Enhanced Exam Edition</div>
    </header>

    <div id="game-container">
        <div id="info-panel">
            <div class="info-item">Level: <span id="level-display">1</span></div>
            <div class="info-item">Mode: <span id="mode-name" style="color: var(--highlight);">Basic Hashing</span></div>
            <div class="info-item">Score: <span id="score">0</span></div>
            <div class="info-item">
                <label>
                    <input type="checkbox" id="toggle-working">
                    Show working
                </label>
            </div>
            <div class="info-item">
                <label>
                    <input type="checkbox" id="toggle-sound" checked>
                    Sound
                </label>
            </div>
            <div id="arcade-timer" class="hidden">
                <div id="arcade-timer-label">
                    <span>ðŸ‘¾ Arcade Time</span>
                    <span><span id="arcade-time-display">0</span>s left</span>
                </div>
                <div id="arcade-timer-bar">
                    <div id="arcade-timer-fill"></div>
                </div>
            </div>
        </div>

        <div id="current-card-area"></div>

        <div id="feedback"></div>

        <div id="memory-grid" role="grid" aria-label="Hash table memory slots"></div>
    </div>

    <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-desc">
        <div class="modal-content">
            <h2 id="modal-title">Welcome, Controller</h2>
            <p id="modal-desc">You are responsible for storing data records efficiently.</p>
            
            <div id="modal-theory" style="background: #181825; padding: 15px; margin: 15px 0; font-size: 0.95em; text-align: left; border-left: 4px solid var(--highlight);">
                <strong>Mission:</strong> Calculate the correct index using the hashing algorithm and click the memory slot to store the data.
            </div>
            
            <div id="quiz-area" class="hidden quiz-container"></div>

            <button id="action-btn" class="start-btn" data-action="start">START LEVEL 1</button>
        </div>
    </div>

    <!-- SOUND EFFECTS -->
    <!-- Replace src paths with your actual files -->
    <audio id="sound-correct" src="correct.mp3" preload="auto"></audio>
    <audio id="sound-wrong" src="wrong.mp3" preload="auto"></audio>
    <audio id="sound-levelup" src="levelup.mp3" preload="auto"></audio>
    <audio id="sound-click" src="click.mp3" preload="auto"></audio>

    <script>
        // --- GAME CONFIGURATION & DATA ---

        const levels = [
            {
                name: "The Perfect Hash",
                algorithm: "Index = Key MOD 11",
                theory: "A hashing algorithm calculates an index from the key. Ideally, every key maps to a unique slot (no collisions).",
                mode: "basic",
                tableSize: 11,
                cards: [
                    { key: 22, value: "User A" },
                    { key: 45, value: "User B" },
                    { key: 14, value: "User C" },
                    { key: 53, value: "User D" },
                    { key: 10, value: "User E" }
                ]
            },
            {
                name: "Collision (Rehashing)",
                algorithm: "Index = Key MOD 11 (Linear Probing)",
                theory: "When a collision occurs (slot occupied), linear probing checks the next slot, then the next, until an empty one is found.",
                mode: "probing",
                tableSize: 11,
                cards: [
                    { key: 33, value: "Rec 1" },
                    { key: 11, value: "Rec 2" },
                    { key: 56, value: "Rec 3" },
                    { key: 23, value: "Rec 4" }
                ]
            },
            {
                name: "The Chain Gang (Chaining)",
                algorithm: "Index = Key MOD 13 (Chaining)",
                theory: "Chaining uses a list at each slot. If a collision occurs, add the new item to the list at that index. The table size is now 13.",
                mode: "chaining",
                tableSize: 13,
                cards: [
                    { key: 25, value: "Data X" },
                    { key: 38, value: "Data Y" },
                    { key: 51, value: "Data Z" }
                ]
            },
            {
                name: "Search & Retrieval (O(1))",
                algorithm: "Index = Key MOD 11",
                theory: "Hashing lets you jump straight to the data. Use Key MOD 11 to calculate where to start the lookup.",
                mode: "search",
                tableSize: 11,
                preLoadedData: [
                    { key: 11, index: 0, value: "Rec A" },
                    { key: 45, index: 1, value: "Rec B" },
                    { key: 22, index: 2, value: "Rec C" },
                    { key: 8,  index: 8, value: "Rec D" }
                ],
                cards: [
                    { key: 45, value: "Rec B", index: 1 },
                    { key: 22, value: "Rec C", index: 2 },
                    { key: 8,  value: "Rec D", index: 8 }
                ]
            },
            {
                name: "Retro Arcade: Hash Invaders",
                algorithm: "Index = Key MOD 11 (Linear Probing)",
                theory: "Timed speed round! Random hash invaders fall in. Use Key MOD 11 with linear probing to place them before the timer hits zero.",
                mode: "arcade",
                tableSize: 11,
                cards: [],           // generated dynamically
                timeLimitMs: 30000   // 30 seconds
            },
            {
                name: "BOSS LEVEL: EXAM SIMULATOR",
                algorithm: "A-Level Theory",
                theory: "Multiple-choice questions based on AQA-style hash table and dictionary questions.",
                mode: "quiz",
                tableSize: 11,
                cards: []
            }
        ];

        const examQuestions = [
            {
                q: "A hash table uses the algorithm Index = Key MOD 10. At which index should a record with key 37 first be placed?",
                options: ["Index 3", "Index 7", "Index 10", "Index 5"],
                answer: 1,
                explanation: "37 Ã· 10 = 3 remainder 7, so the hash value / index is 7."
            },
            {
                q: "Why is a hash table a suitable data structure for implementing a dictionary of word â†’ definition?",
                options: [
                    "Because it always stores items in alphabetical order",
                    "Because it allows near-instant access to the value using the key",
                    "Because it can only store numeric values",
                    "Because it automatically encrypts the data"
                ],
                answer: 1,
                explanation: "A dictionary maps keys to values. A hash table uses a hash function to jump directly to the location for a key, giving very fast lookup."
            },
            {
                q: "Two different keys produce the same hash value when inserted into a hash table using linear probing. What happens next?",
                options: [
                    "The second key is discarded",
                    "The second key overwrites the first key",
                    "The algorithm searches sequentially for the next empty slot",
                    "Both keys are placed in a queue"
                ],
                answer: 2,
                explanation: "With linear probing, the algorithm checks the next slot (and then the next, etc.) until it finds an empty position for the new item."
            },
            {
                q: "In chaining, how are collisions handled in a hash table?",
                options: [
                    "By completely recalculating the hash function",
                    "By storing additional items in a linked list at the same index",
                    "By deleting the older record",
                    "By resizing the table every time a collision happens"
                ],
                answer: 1,
                explanation: "Chaining keeps a list of all the records whose keys hash to the same index, so multiple records can share one slot."
            },
            {
                q: "A hash table uses Index = Key MOD 11. A record with key 45 is stored at index 1. Which of the following best describes how the index 1 was found?",
                options: [
                    "By dividing 45 by 11 and using the quotient",
                    "By adding 11 repeatedly until 45 is reached",
                    "By finding the remainder when 45 is divided by 11",
                    "By subtracting 11 repeatedly until 0 is reached"
                ],
                answer: 2,
                explanation: "45 Ã· 11 = 4 remainder 1. The index is the remainder from Key MOD TableSize."
            },
            {
                q: "Assuming a good hashing algorithm, what is the typical time complexity to look up a value in a hash table?",
                options: [
                    "O(nÂ²)",
                    "O(log n)",
                    "O(n)",
                    "O(1) on average"
                ],
                answer: 3,
                explanation: "A well-designed hash table gives constant-time average lookups, O(1), because it jumps straight to the slot using the key."
            }
        ];

        // --- GAME STATE & DOM REFERENCES ---
        let currentLevel = 0;
        let score = 0;
        let currentCardIndex = 0;
        let currentQuizIndex = 0;
        let memory = [];
        let tableSize = 11;
        let showWorking = false;
        let quizLocked = false;
        let soundEnabled = true;

        // Arcade-specific state
        let arcadeActive = false;
        let arcadeTimeRemaining = 0;
        let arcadeTimeLimit = 0;
        let arcadeTimerInterval = null;
        let arcadeCurrentCard = null;

        const gridEl = document.getElementById('memory-grid');
        const cardArea = document.getElementById('current-card-area');
        const feedback = document.getElementById('feedback');
        const modal = document.getElementById('modal');
        const quizArea = document.getElementById('quiz-area');
        const actionBtn = document.getElementById('action-btn');
        const workingToggle = document.getElementById('toggle-working');
        const soundToggle = document.getElementById('toggle-sound');
        const arcadeTimerEl = document.getElementById('arcade-timer');
        const arcadeTimeDisplay = document.getElementById('arcade-time-display');
        const arcadeTimerFill = document.getElementById('arcade-timer-fill');

        // --- SOUND HANDLING ---

        function playSound(name) {
            if (!soundEnabled) return;
            const audio = document.getElementById('sound-' + name);
            if (!audio) return;
            try {
                audio.currentTime = 0;
                audio.play().catch(() => {});
            } catch (_) {}
        }

        // --- CORE FUNCTIONS ---

        function initGrid() {
            gridEl.innerHTML = '';
            tableSize = levels[currentLevel].tableSize;

            memory = new Array(tableSize).fill(null);
            if (levels[currentLevel].mode === 'chaining') {
                for (let i = 0; i < tableSize; i++) {
                    memory[i] = [];
                }
            }

            for (let i = 0; i < tableSize; i++) {
                const slot = document.createElement('div');
                slot.className = 'memory-slot';
                slot.dataset.index = i;
                slot.setAttribute('role', 'gridcell');
                slot.setAttribute('aria-label', `Index ${i}`);
                slot.tabIndex = 0;

                slot.addEventListener('click', () => handleSlotClick(i));
                slot.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleSlotClick(i);
                    }
                });

                const indexLabel = document.createElement('div');
                indexLabel.className = 'slot-index';
                indexLabel.innerText = `Idx ${i}`;

                slot.appendChild(indexLabel);
                gridEl.appendChild(slot);
            }

            if (levels[currentLevel].mode === 'search') {
                levels[currentLevel].preLoadedData.forEach(data => {
                    updateMemoryVisuals(data.index, data, { isPreloading: true });
                });
            }
        }

        function updateArcadeTimerUI() {
            const seconds = Math.max(0, Math.ceil(arcadeTimeRemaining / 1000));
            arcadeTimeDisplay.textContent = seconds;
            const ratio = arcadeTimeLimit > 0 ? arcadeTimeRemaining / arcadeTimeLimit : 0;
            arcadeTimerFill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
        }

        function startArcadeMode() {
            const levelData = levels[currentLevel];
            arcadeActive = true;
            arcadeTimeLimit = levelData.timeLimitMs || 30000;
            arcadeTimeRemaining = arcadeTimeLimit;

            arcadeTimerEl.classList.remove('hidden');
            updateArcadeTimerUI();

            if (arcadeTimerInterval) {
                clearInterval(arcadeTimerInterval);
            }

            arcadeTimerInterval = setInterval(() => {
                arcadeTimeRemaining -= 1000;
                if (arcadeTimeRemaining <= 0) {
                    arcadeTimeRemaining = 0;
                    updateArcadeTimerUI();
                    endArcadeLevel();
                } else {
                    updateArcadeTimerUI();
                }
            }, 1000);

            generateArcadeCard();
        }

        function stopArcadeMode() {
            arcadeActive = false;
            if (arcadeTimerInterval) {
                clearInterval(arcadeTimerInterval);
                arcadeTimerInterval = null;
            }
            arcadeTimerEl.classList.add('hidden');
        }

        function endArcadeLevel() {
            if (!arcadeActive) return;
            stopArcadeMode();
            displayFeedback("Time up! Retro wave complete. Final arcade score: " + score, true);
            playSound('levelup');
            endLevel();
        }

        function generateArcadeCard() {
            // Generate a random key in a nice range (retro invader ID)
            const key = Math.floor(Math.random() * 90) + 10; // 10â€“99
            arcadeCurrentCard = {
                key,
                value: "ðŸ‘¾ Invader #" + key
            };
            showCard(); // will render using arcadeCurrentCard
        }

        function showCard() {
            const levelData = levels[currentLevel];
            if (levelData.mode === 'quiz') return;

            if (levelData.mode !== 'arcade' && currentCardIndex >= levelData.cards.length) {
                endLevel();
                return;
            }

            let cardData;
            if (levelData.mode === 'arcade') {
                cardData = arcadeCurrentCard;
            } else {
                cardData = levelData.cards[currentCardIndex];
            }

            const mod = levelData.tableSize;
            const baseHash = cardData.key % mod;
            const division = Math.floor(cardData.key / mod);
            const remainder = baseHash;

            let workingHtml = "";
            if (showWorking) {
                workingHtml = `
                    <div class="data-card-working">
                        ${cardData.key} Ã· ${mod} = ${division} remainder ${remainder}<br>
                        ${cardData.key} % ${mod} = ${remainder}
                    </div>
                `;
            } else {
                const showHash = (levelData.mode === 'search' || levelData.mode === 'arcade') ? baseHash : "?";
                workingHtml = `
                    <div class="data-card-working">
                        HASH: ${cardData.key} % ${mod} = ${showHash}
                    </div>
                `;
            }

            if (levelData.mode === 'search') {
                cardArea.innerHTML = `
                    <div class="data-card" style="background: var(--highlight); color: #111;">
                        <div class="data-card-main">
                            <span style="font-size:0.8em;">FIND THIS KEY:</span><br>
                            KEY: ${cardData.key}
                        </div>
                        <div class="data-card-sub">
                            Use the hash to jump to the starting index and locate the record.
                        </div>
                        ${workingHtml}
                    </div>
                `;
            } else if (levelData.mode === 'arcade') {
                cardArea.innerHTML = `
                    <div class="data-card" style="background: #f38ba8; color: #111;">
                        <div class="data-card-main">
                            ðŸ‘¾ INVADER INCOMING<br>KEY: ${cardData.key}
                        </div>
                        <div class="data-card-sub">
                            Place the invader using Key MOD ${mod} with linear probing before time runs out!
                        </div>
                        ${workingHtml}
                    </div>
                `;
            } else {
                cardArea.innerHTML = `
                    <div class="data-card">
                        <div class="data-card-main">KEY: ${cardData.key}</div>
                        <div class="data-card-sub">${cardData.value}</div>
                        ${workingHtml}
                    </div>
                `;
            }
        }

        function pulseSlot(index, isCorrect) {
            const slotEl = gridEl.children[index];
            const className = isCorrect ? 'slot-pulse-correct' : 'slot-pulse-wrong';
            slotEl.classList.add(className);
            setTimeout(() => {
                slotEl.classList.remove(className);
            }, 450);
        }

        function highlightProbePath(pathIndices) {
            pathIndices.forEach((idx, step) => {
                const slotEl = gridEl.children[idx];
                setTimeout(() => {
                    slotEl.classList.add('slot-probe-path');
                    setTimeout(() => slotEl.classList.remove('slot-probe-path'), 400);
                }, step * 120);
            });
        }

        function handleSlotClick(clickedIndex) {
            const levelData = levels[currentLevel];
            if (levelData.mode === 'quiz') return;

            const currentCard = (levelData.mode === 'arcade')
                ? arcadeCurrentCard
                : levelData.cards[currentCardIndex];

            const mod = levelData.tableSize;
            const rawHash = currentCard.key % mod;

            let correctIndex = -1;
            let success = false;
            let msg = "Incorrect.";

            if (levelData.mode === 'search') {
                correctIndex = currentCard.index;
                if (clickedIndex === correctIndex) {
                    success = true;
                    msg = `SUCCESS! Key ${currentCard.key} found at Index ${correctIndex}. Lookup: O(1) on average.`;
                    score += 15;
                    playSound('correct');
                } else {
                    msg = `Key not found at Index ${clickedIndex}. Start from hash ${rawHash} and follow the table.`;
                    score = Math.max(0, score - 5);
                    playSound('wrong');
                }
            } else {
                if (levelData.mode === 'basic') {
                    correctIndex = rawHash;
                } else if (levelData.mode === 'probing' || levelData.mode === 'arcade') {
                    let probe = rawHash;
                    let loopGuard = 0;
                    while (memory[probe] !== null && loopGuard < mod + 1) {
                        probe = (probe + 1) % mod;
                        loopGuard++;
                    }
                    correctIndex = probe;

                    const path = [];
                    let idx = rawHash;
                    while (true) {
                        path.push(idx);
                        if (idx === correctIndex) break;
                        idx = (idx + 1) % mod;
                    }
                    highlightProbePath(path);
                } else if (levelData.mode === 'chaining') {
                    correctIndex = rawHash;
                }

                if (clickedIndex === correctIndex) {
                    success = true;
                    score += (levelData.mode === 'arcade') ? 15 : 10;
                    msg = levelData.mode === 'arcade'
                        ? "Nice shot! Invader stored."
                        : "Correct allocation!";
                    updateMemoryVisuals(clickedIndex, currentCard);
                    playSound('correct');
                } else {
                    score = Math.max(0, score - 5);
                    if (levelData.mode === 'basic') {
                        msg = `Wrong! ${currentCard.key} % ${mod} = ${rawHash}.`;
                    } else if (levelData.mode === 'probing' || levelData.mode === 'arcade') {
                        msg = `Collision resolution needed. Start at ${rawHash} and probe to the next empty slot (Index ${correctIndex}).`;
                    } else if (levelData.mode === 'chaining') {
                        msg = `Wrong! In chaining, always store at the hashed index (${rawHash}) and add to the list.`;
                    }
                    playSound('wrong');
                }
            }

            pulseSlot(clickedIndex, success);
            displayFeedback(msg, success);
            updateScore();

            if (success) {
                if (levelData.mode === 'arcade') {
                    generateArcadeCard();
                } else {
                    currentCardIndex++;
                    showCard();
                }
            }
        }

        function renderStoredKey(slotEl, card, { faded }) {
            const item = document.createElement('div');
            item.className = 'stored-item';
            item.innerText = card.key;
            if (faded) {
                item.style.backgroundColor = 'var(--slot-bg)';
                item.style.color = 'var(--highlight)';
            }
            slotEl.appendChild(item);
        }

        function updateMemoryVisuals(index, card, options = {}) {
            const { isPreloading = false } = options;
            const levelData = levels[currentLevel];
            const slotEl = gridEl.children[index];

            if (levelData.mode === 'chaining') {
                memory[index].push(card);
                if (memory[index].length > 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'linked-arrow';
                    arrow.innerHTML = '&#8595;';
                    slotEl.appendChild(arrow);
                }
                renderStoredKey(slotEl, card, { faded: false });
                return;
            }

            if (levelData.mode === 'search' && isPreloading) {
                memory[index] = card;
                renderStoredKey(slotEl, card, { faded: true });
                return;
            }

            memory[index] = card;
            renderStoredKey(slotEl, card, { faded: false });
        }

        function displayFeedback(msg, isSuccess) {
            feedback.innerText = msg;
            feedback.style.color = isSuccess ? "var(--success)" : "var(--error)";
            setTimeout(() => {
                if (feedback.innerText === msg) {
                    feedback.innerText = "";
                }
            }, 4000);
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
        }

        // --- QUIZ LOGIC ---

        let quizStarted = false;

        function startQuiz() {
            currentQuizIndex = 0;
            quizLocked = false;
            quizStarted = true;
            renderQuestion();
            playSound('levelup');
        }

        function renderQuestion() {
            if (currentQuizIndex >= examQuestions.length) {
                document.getElementById('modal-title').innerText = "Assessment Complete";
                document.getElementById('modal-desc').innerText = `Final Score: ${score}`;
                document.getElementById('modal-theory').innerHTML =
                    "You have practised hash table insertion, collision handling, retrieval and dictionary-style usage. Review any explanations you found tricky, then conquer the real paper.";
                quizArea.classList.add('hidden');
                quizArea.innerHTML = "";
                actionBtn.classList.remove('hidden');
                actionBtn.innerText = "Reset System";
                actionBtn.dataset.action = "reset";
                return;
            }

            const q = examQuestions[currentQuizIndex];

            let html = `
                <div class="quiz-question">Q${currentQuizIndex + 1}: ${q.q}</div>
                <div class="quiz-options">
                    ${q.options.map((opt, idx) =>
                        `<button type="button" class="quiz-option" data-index="${idx}">${opt}</button>`
                    ).join('')}
                </div>
                <div id="quiz-explanation" class="quiz-explanation hidden"></div>
                <button id="quiz-next-btn" type="button" class="start-btn quiz-next-btn" disabled>Next Question</button>
            `;

            quizArea.innerHTML = html;
            quizArea.classList.remove('hidden');
            quizLocked = false;
        }

        function handleQuizAnswer(selectedIdx) {
            if (quizLocked) return;
            quizLocked = true;

            const q = examQuestions[currentQuizIndex];
            const opts = quizArea.querySelectorAll('.quiz-option');

            opts.forEach(o => {
                o.disabled = true;
            });

            if (selectedIdx === q.answer) {
                opts[selectedIdx].classList.add('correct');
                score += 20;
                displayFeedback("Correct!", true);
                playSound('correct');
            } else {
                opts[selectedIdx].classList.add('wrong');
                opts[q.answer].classList.add('correct');
                score = Math.max(0, score - 10);
                displayFeedback("Incorrect.", false);
                playSound('wrong');
            }
            updateScore();

            const expEl = document.getElementById('quiz-explanation');
            if (expEl) {
                expEl.textContent = "Explanation: " + q.explanation;
                expEl.classList.remove('hidden');
            }

            const nextBtn = document.getElementById('quiz-next-btn');
            if (nextBtn) {
                nextBtn.disabled = false;
            }
        }

        function goToNextQuestion() {
            currentQuizIndex++;
            renderQuestion();
        }

        // --- FLOW CONTROL ---

        function startGame() {
            try {
                // Any time we start a level, make sure arcade timers are off
                stopArcadeMode();
                modal.classList.add('hidden');

                document.getElementById('level-display').innerText = currentLevel + 1;
                document.getElementById('mode-name').innerText = levels[currentLevel].name;

                const levelData = levels[currentLevel];

                if (levelData.mode === 'quiz') {
                    gridEl.innerHTML =
                        '<div style="grid-column: 1/-1; text-align: center; padding: 50px; color: var(--accent); font-size: 1.6em; opacity:0.6;">THEORY MODE ACTIVE</div>';
                    cardArea.innerHTML =
                        '<div style="color:#fff; font-size:0.95em;">Calculating Theory Knowledge...</div>';

                    modal.classList.remove('hidden');
                    document.getElementById('modal-title').innerText = "BOSS LEVEL";
                    document.getElementById('modal-desc').innerText = "Multiple-choice exam-style questions";
                    document.getElementById('modal-theory').innerHTML =
                        "Answer correctly for bonus points. Wrong answers lose points. Read the explanations â€“ they mirror how mark schemes award marks.";

                    quizArea.classList.remove('hidden');
                    actionBtn.classList.add('hidden');
                    startQuiz();
                } else if (levelData.mode === 'arcade') {
                    initGrid();
                    startArcadeMode();
                    playSound('levelup');
                } else {
                    initGrid();
                    showCard();
                    playSound('levelup');
                }
            } catch (e) {
                alert("Error starting game: " + e.message + "\nCheck browser console for details.");
                console.error(e);
            }
        }

        function endLevel() {
            currentLevel++;
            if (currentLevel < levels.length) {
                document.getElementById('modal-title').innerText = `Level ${currentLevel} Complete`;
                document.getElementById('modal-desc').innerText = `Next up: ${levels[currentLevel].name}`;
                document.getElementById('modal-theory').innerHTML =
                    `<strong>New Rule:</strong> ${levels[currentLevel].theory}`;

                currentCardIndex = 0;
                actionBtn.innerText = "Start Next Level";
                actionBtn.classList.remove('hidden');
                actionBtn.dataset.action = "start";
                quizArea.classList.add('hidden');

                modal.classList.remove('hidden');
                actionBtn.focus();
                playSound('levelup');
            } else {
                // Shouldn't normally get here because quiz is final and doesn't call endLevel in same way
                startGame();
            }
        }

        // --- SAFE INITIALIZATION ---

        document.addEventListener('DOMContentLoaded', function () {
            actionBtn.addEventListener('click', () => {
                const mode = actionBtn.dataset.action;
                playSound('click');
                if (mode === "start") {
                    startGame();
                } else if (mode === "reset") {
                    location.reload();
                }
            });

            if (workingToggle) {
                workingToggle.addEventListener('change', (e) => {
                    showWorking = e.target.checked;
                    showCard();
                });
            }

            if (soundToggle) {
                soundToggle.addEventListener('change', (e) => {
                    soundEnabled = e.target.checked;
                    if (soundEnabled) playSound('click');
                });
            }

            quizArea.addEventListener('click', (e) => {
                const option = e.target.closest('.quiz-option');
                if (option) {
                    const idx = Number(option.dataset.index);
                    if (!Number.isNaN(idx)) {
                        handleQuizAnswer(idx);
                    }
                    return;
                }

                const nextBtn = e.target.closest('#quiz-next-btn');
                if (nextBtn && !nextBtn.disabled) {
                    playSound('click');
                    goToNextQuestion();
                }
            });
        });
    </script>
</body>
</html>
