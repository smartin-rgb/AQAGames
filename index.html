<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hash-Crash Scheduler: Final Exam Edition</title>
    <style>
        :root {
            --bg-color: #1e1e2e;
            --card-bg: #313244;
            --slot-bg: #45475a;
            --accent: #89b4fa;
            --success: #a6e3a1;
            --error: #f38ba8;
            --text: #cdd6f4;
            --highlight: #f9e2af;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        header { text-align: center; margin: 20px 0; }
        h1 { color: var(--accent); margin-bottom: 5px; font-size: 1.8rem; }
        .subtitle { font-size: 0.9em; opacity: 0.8; }

        #game-container {
            width: 90%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Info Panel */
        #info-panel {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            flex-wrap: wrap;
            gap: 10px;
        }

        #info-panel .info-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #info-panel label {
            font-size: 0.8rem;
            cursor: pointer;
        }

        /* Level explanation block */
        #level-explanation {
            background: #181825;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.85rem;
            border-left: 4px solid var(--highlight);
            line-height: 1.4;
        }
        #level-explanation-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--highlight);
        }

        /* Arcade timer (for arcade level) */
        #arcade-timer {
            background: #181825;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.85rem;
        }

        #arcade-timer-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #arcade-timer-bar {
            width: 100%;
            height: 8px;
            background: #313244;
            border-radius: 999px;
            overflow: hidden;
        }

        #arcade-timer-fill {
            width: 100%;
            height: 100%;
            background: var(--accent);
            transform-origin: left center;
            transition: width 0.3s linear;
        }

        /* Current Data Card */
        #current-card-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 120px;
            background: #181825;
            border-radius: 8px;
            border: 2px dashed var(--text);
            margin-bottom: 20px;
        }

        .data-card {
            background: var(--accent);
            color: #111;
            padding: 15px 30px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: popIn 0.3s ease;
            text-align: center;
            min-width: 220px;
        }

        .data-card-main {
            margin-bottom: 4px;
        }

        .data-card-sub {
            font-size: 0.75em;
            font-weight: normal;
            opacity: 0.85;
        }

        .data-card-working {
            font-size: 0.7em;
            background: rgba(0,0,0,0.35);
            margin-top: 6px;
            padding: 3px;
            border-radius: 3px;
        }

        @keyframes popIn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        /* Memory Grid */
        #memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 40px;
        }

        .memory-slot {
            background: var(--slot-bg);
            border: 2px solid #585b70;
            border-radius: 5px;
            min-height: 100px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            outline: none;
        }

        .memory-slot:hover,
        .memory-slot:focus-visible {
            border-color: var(--accent);
            background: #585b70;
            transform: translateY(-2px);
        }

        /* Pulse Feedback */
        .slot-pulse-correct {
            animation: pulse-correct 0.4s ease-out;
        }

        .slot-pulse-wrong {
            animation: pulse-wrong 0.4s ease-out;
        }

        @keyframes pulse-correct {
            0% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(166, 227, 161, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0); }
        }

        @keyframes pulse-wrong {
            0% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(243, 139, 168, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0); }
        }

        /* Probe path highlight */
        .slot-probe-path {
            animation: probe-glow 0.6s ease-out;
        }

        @keyframes probe-glow {
            0% { box-shadow: 0 0 0 0 rgba(137, 180, 250, 0.7); }
            100% { box-shadow: 0 0 0 0 rgba(137, 180, 250, 0); }
        }

        .slot-index {
            font-size: 0.8em;
            color: #9399b2;
            margin-bottom: 5px;
            border-bottom: 1px solid #9399b2;
            width: 100%;
            text-align: center;
        }

        .stored-item {
            background: var(--accent);
            color: #111;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-top: 2px;
            width: 90%;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .linked-arrow {
            color: var(--text);
            font-size: 0.8em;
        }

        /* Feedback Area */
        #feedback {
            text-align: center;
            min-height: 30px;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        /* Modal */
        #modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 650px;
            width: 90%;
            text-align: center;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(137, 180, 250, 0.2);
            max-height: 90vh;
            overflow-y: auto;
        }

        .start-btn {
            background: var(--accent);
            color: #1e1e2e;
            border: none;
            padding: 12px 30px;
            font-size: 1.05em;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: 900;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 12px rgba(137,180,250,0.6);
        }

        .hidden { display: none !important; }

        /* Quiz Styles */
        .quiz-container {
            text-align: left;
            margin-top: 20px;
            max-height: 320px;
            overflow-y: auto;
        }
        .quiz-question {
            font-size: 1.05em;
            margin-bottom: 15px;
            color: var(--highlight);
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .quiz-option {
            background: var(--slot-bg);
            padding: 10px 12px;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #585b70;
            transition: background 0.2s, transform 0.05s;
            font-family: inherit;
            font-size: 0.95em;
            text-align: left;
        }
        .quiz-option:hover:enabled {
            background: #585b70;
            transform: translateY(-1px);
        }
        .quiz-option.correct {
            background: var(--success);
            color: #111;
            border-color: var(--success);
        }
        .quiz-option.wrong {
            background: var(--error);
            color: #111;
            border-color: var(--error);
        }
        .quiz-explanation {
            font-size: 0.85em;
            background: #181825;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid var(--highlight);
        }
        .quiz-next-btn {
            font-size: 0.9em;
            padding: 8px 16px;
            margin-top: 10px;
        }
        .quiz-next-btn:disabled {
            opacity: 0.5;
            cursor: default;
            box-shadow: none;
            transform: none;
        }

        /* Session summary + log export */
        #session-summary {
            text-align: left;
            font-size: 0.9em;
            margin-top: 15px;
            background: #181825;
            padding: 12px;
            border-radius: 8px;
        }
        #session-summary ul {
            padding-left: 20px;
        }
        #session-log-container {
            margin-top: 15px;
            text-align: left;
        }
        #session-log-text {
            width: 100%;
            height: 140px;
            background: #11111b;
            color: var(--text);
            border-radius: 6px;
            border: 1px solid #585b70;
            padding: 8px;
            font-family: monospace;
            font-size: 0.8em;
            resize: vertical;
        }
        #copy-log-btn {
            margin-top: 8px;
            font-size: 0.85em;
            padding: 6px 16px;
        }

        /* Quiz timer in modal */
        #quiz-timer {
            margin-top: 5px;
            font-size: 0.9em;
            opacity: 0.85;
        }

        @media (max-width: 600px) {
            .data-card {
                padding: 12px 16px;
                font-size: 1em;
            }
            #info-panel {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>The Hash-Crash Scheduler</h1>
        <div class="subtitle">AQA A-Level Computer Science: Enhanced Exam Edition</div>
    </header>

    <div id="game-container">
        <div id="info-panel">
            <div class="info-item">Level: <span id="level-display">1</span></div>
            <div class="info-item">Mode: <span id="mode-name" style="color: var(--highlight);">Basic Hashing</span></div>
            <div class="info-item">Score: <span id="score">0</span></div>
            <div class="info-item">
                <label>
                    <input type="checkbox" id="toggle-working">
                    Show working
                </label>
            </div>
            <div class="info-item">
                <label>
                    <input type="checkbox" id="toggle-sound" checked>
                    Sound
                </label>
            </div>
            <div id="arcade-timer" class="hidden">
                <div id="arcade-timer-label">
                    <span>üëæ Arcade Time</span>
                    <span><span id="arcade-time-display">0</span>s left</span>
                </div>
                <div id="arcade-timer-bar">
                    <div id="arcade-timer-fill"></div>
                </div>
            </div>
        </div>

        <!-- always-visible current level explanation -->
        <div id="level-explanation">
            <div id="level-explanation-title">Level 1 ‚Äì The Perfect Hash</div>
            <div id="level-explanation-body">
                A hashing algorithm calculates an index from the key. Ideally, every key maps to a unique slot (no collisions).
            </div>
        </div>

        <div id="current-card-area" aria-live="polite"></div>

        <div id="feedback" aria-live="polite"></div>

        <div id="memory-grid" role="grid" aria-label="Hash table memory slots"></div>
    </div>

    <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-desc">
        <div class="modal-content">
            <h2 id="modal-title">Welcome, Controller</h2>
            <p id="modal-desc">You are responsible for storing data records efficiently.</p>
            
            <div id="modal-theory" style="background: #181825; padding: 15px; margin: 15px 0; font-size: 0.95em; text-align: left; border-left: 4px solid var(--highlight);">
                <strong>Mission:</strong> Calculate the correct index using the hashing algorithm and click the memory slot to store the data.
            </div>

            <!-- Quiz timer (shown only in quiz mode) -->
            <div id="quiz-timer" class="hidden">
                ‚è± Quiz time left: <span id="quiz-time-display">0</span>s
            </div>
            
            <div id="quiz-area" class="hidden quiz-container"></div>

            <!-- session summary & JSON export area -->
            <div id="session-summary" class="hidden"></div>
            <div id="session-log-container" class="hidden">
                <h3 style="font-size:1em; margin-top:15px;">Session event log (JSON)</h3>
                <textarea id="session-log-text" readonly></textarea>
                <button id="copy-log-btn" class="start-btn" type="button">Copy session log</button>
            </div>

            <button id="action-btn" class="start-btn" data-action="start">START LEVEL 1</button>
        </div>
    </div>

    <script>
        // --- GAME CONFIGURATION & DATA ---

        const levels = [
            {
                name: "The Perfect Hash",
                algorithm: "Index = Key MOD 11",
                theory: "A hashing algorithm calculates an index from the key. Ideally, every key maps to a unique slot (no collisions).",
                mode: "basic",
                tableSize: 11,
                cards: [
                    { key: 22, value: "User A" },
                    { key: 45, value: "User B" },
                    { key: 14, value: "User C" },
                    { key: 53, value: "User D" },
                    { key: 10, value: "User E" }
                ]
            },
            {
                name: "Collision (Rehashing)",
                algorithm: "Index = Key MOD 11 (Linear Probing)",
                theory: "When a collision occurs (slot occupied), linear probing checks the next slot, then the next, until an empty one is found.",
                mode: "probing",
                tableSize: 11,
                cards: [
                    { key: 33, value: "Rec 1" },
                    { key: 11, value: "Rec 2" },
                    { key: 56, value: "Rec 3" },
                    { key: 23, value: "Rec 4" }
                ]
            },
            {
                name: "The Chain Gang (Chaining)",
                algorithm: "Index = Key MOD 13 (Chaining)",
                theory: "Chaining uses a list at each slot. If a collision occurs, add the new item to the list at that index. The table size is now 13.",
                mode: "chaining",
                tableSize: 13,
                cards: [
                    { key: 25, value: "Data X" },
                    { key: 38, value: "Data Y" },
                    { key: 51, value: "Data Z" }
                ]
            },
            {
                name: "Search & Retrieval (O(1))",
                algorithm: "Index = Key MOD 11",
                theory: "Hashing lets you jump straight to the data. Use Key MOD 11 to calculate where to start the lookup.",
                mode: "search",
                tableSize: 11,
                preLoadedData: [
                    { key: 11, index: 0, value: "Rec A" },
                    { key: 45, index: 1, value: "Rec B" },
                    { key: 22, index: 2, value: "Rec C" },
                    { key: 8,  index: 8, value: "Rec D" }
                ],
                cards: [
                    { key: 45, value: "Rec B", index: 1 },
                    { key: 22, value: "Rec C", index: 2 },
                    { key: 8,  value: "Rec D", index: 8 }
                ]
            },
            {
                name: "Word Wizard (Dictionaries)",
                algorithm: "Dictionary: key ‚Üí hash(key) ‚Üí index",
                theory: "A dictionary maps unique keys (like words) to values (like definitions). A hash table stores these pairs so that you can look up a word in O(1) time on average.",
                mode: "dictionary",
                tableSize: 11,
                preLoadedData: [
                    // key % 11 == index
                    { key: 21, index: 10, word: "cat",   value: "A small domesticated animal" },
                    { key: 34, index:  1, word: "tree",  value: "A tall plant with a trunk" },
                    { key: 57, index:  2, word: "hash",  value: "Function that maps data to an index" },
                    { key: 15, index:  4, word: "array", value: "A contiguous block of memory storing elements" }
                ],
                cards: [
                    { key: 21, index: 10, word: "cat",   value: "A small domesticated animal" },
                    { key: 34, index:  1, word: "tree",  value: "A tall plant with a trunk" },
                    { key: 57, index:  2, word: "hash",  value: "Function that maps data to an index" },
                    { key: 15, index:  4, word: "array", value: "A contiguous block of memory storing elements" }
                ]
            },
            {
                name: "Retro Arcade: Hash Invaders",
                algorithm: "Index = Key MOD 11 (Linear Probing)",
                theory: "Timed speed round! Random hash invaders fall in. Use Key MOD 11 with linear probing to place them before the timer hits zero.",
                mode: "arcade",
                tableSize: 11,
                cards: [],
                timeLimitMs: 30000
            },
            {
                name: "BOSS LEVEL: EXAM SIMULATOR",
                algorithm: "A-Level Theory",
                theory: "Multiple-choice questions based on AQA-style hash table and dictionary questions. Timed drill: keep going until the clock hits zero.",
                mode: "quiz",
                tableSize: 11,
                cards: []
            }
        ];

        // Extended question bank
        const examQuestions = [
            {
                q: "A hash table uses the algorithm Index = Key MOD 10. At which index should a record with key 37 first be placed?",
                options: ["Index 3", "Index 7", "Index 10", "Index 5"],
                answer: 1,
                explanation: "37 √∑ 10 = 3 remainder 7, so the hash value / index is 7."
            },
            {
                q: "Why is a hash table a suitable data structure for implementing a dictionary of word ‚Üí definition?",
                options: [
                    "Because it always stores items in alphabetical order",
                    "Because it allows near-instant access to the value using the key",
                    "Because it can only store numeric values",
                    "Because it automatically encrypts the data"
                ],
                answer: 1,
                explanation: "A dictionary maps keys to values. A hash table uses a hash function to jump directly to the location for a key, giving very fast lookup."
            },
            {
                q: "Two different keys produce the same hash value when inserted into a hash table using linear probing. What happens next?",
                options: [
                    "The second key is discarded",
                    "The second key overwrites the first key",
                    "The algorithm searches sequentially for the next empty slot",
                    "Both keys are placed in a queue"
                ],
                answer: 2,
                explanation: "With linear probing, the algorithm checks the next slot (and then the next, etc.) until it finds an empty position for the new item."
            },
            {
                q: "In chaining, how are collisions handled in a hash table?",
                options: [
                    "By completely recalculating the hash function",
                    "By storing additional items in a linked list at the same index",
                    "By deleting the older record",
                    "By resizing the table every time a collision happens"
                ],
                answer: 1,
                explanation: "Chaining keeps a list of all the records whose keys hash to the same index, so multiple records can share one slot."
            },
            {
                q: "A hash table uses Index = Key MOD 11. A record with key 45 is stored at index 1. Which of the following best describes how the index 1 was found?",
                options: [
                    "By dividing 45 by 11 and using the quotient",
                    "By adding 11 repeatedly until 45 is reached",
                    "By finding the remainder when 45 is divided by 11",
                    "By subtracting 11 repeatedly until 0 is reached"
                ],
                answer: 2,
                explanation: "45 √∑ 11 = 4 remainder 1. The index is the remainder from Key MOD TableSize."
            },
            {
                q: "Assuming a good hashing algorithm, what is the typical time complexity to look up a value in a hash table?",
                options: [
                    "O(n¬≤)",
                    "O(log n)",
                    "O(n)",
                    "O(1) on average"
                ],
                answer: 3,
                explanation: "A well-designed hash table gives constant-time average lookups, O(1), because it jumps straight to the slot using the key."
            },
            {
                q: "A hash table has 20 slots and currently stores 12 items. What term describes 12/20?",
                options: [
                    "Load factor",
                    "Collision rate",
                    "Hash value",
                    "Overflow ratio"
                ],
                answer: 0,
                explanation: "Load factor is number of items divided by table size."
            },
            {
                q: "Which is an advantage of chaining over linear probing when the table becomes crowded?",
                options: [
                    "Chaining guarantees no collisions at all",
                    "Chaining avoids long blocks of filled slots and keeps probing short",
                    "Chaining removes the need for a hash function",
                    "Chaining always keeps items in sorted order"
                ],
                answer: 1,
                explanation: "Chaining stores colliding items in a list at one index, so other slots remain free and probe sequences stay short."
            },
            {
                q: "What usually happens to performance as the load factor of a hash table gets very close to 1.0?",
                options: [
                    "Performance improves because the table is fully used",
                    "Performance stays exactly the same",
                    "Performance gets worse because collisions become much more frequent",
                    "The table automatically deletes old records"
                ],
                answer: 2,
                explanation: "High load factor means more collisions, which increases the time spent resolving them."
            },
            {
                q: "A student uses Index = Key MOD 5 for a hash table that stores thousands of records. What is the most likely problem?",
                options: [
                    "The table will always stay empty",
                    "The hash function is not deterministic",
                    "The table will have too few slots, causing many collisions",
                    "The keys will no longer be unique"
                ],
                answer: 2,
                explanation: "A modulus of 5 means only 5 slots. Thousands of records into 5 slots gives extreme collision rates."
            },
            {
                q: "In a hash table used as a symbol table, what is the role of the hash function?",
                options: [
                    "To encrypt the symbols for security",
                    "To translate the key into an index for the underlying array",
                    "To compress the array into a single value",
                    "To ensure the table stays sorted"
                ],
                answer: 1,
                explanation: "The hash function maps a key (e.g. identifier) to an array index where its record is stored."
            },
            {
                q: "Which change is most likely to improve performance when a hash table suffers from many collisions?",
                options: [
                    "Decrease the table size",
                    "Use a worse hash function",
                    "Increase table size and rehash the items",
                    "Remove the hash function entirely"
                ],
                answer: 2,
                explanation: "More slots and rehashing spread keys out, reducing collisions."
            }
        ];

        // --- GAME STATE & DOM REFERENCES ---
        let currentLevel = 0;
        let score = 0;
        let currentCardIndex = 0;
        let currentQuizIndex = 0;
        let memory = [];
        let tableSize = 11;
        let showWorking = false;
        let quizLocked = false;
        let soundEnabled = true;

        // per-card attempt tracking + level stats
        let currentCardAttempts = 0;
        let arcadeCardStartTime = null;

        const levelStats = levels.map(() => ({
            slotCorrect: 0,
            slotIncorrect: 0,
            quizCorrect: 0,
            quizIncorrect: 0,
            firstTryCorrect: 0,
            itemsSeen: 0,
            arcadeTotalTimeMs: 0,
            arcadeItems: 0
        }));

        // session event log
        const sessionEvents = [];

        // Arcade-specific state
        let arcadeActive = false;
        let arcadeTimeRemaining = 0;
        let arcadeTimeLimit = 0;
        let arcadeTimerInterval = null;
        let arcadeCurrentCard = null;

        // Quiz timer state (boss level) ‚Äì 30s per question
        let quizTimeLimitMs = 30000; // 30s per question
        let quizTimeRemaining = 0;
        let quizTimerInterval = null;

        const gridEl = document.getElementById('memory-grid');
        const cardArea = document.getElementById('current-card-area');
        const feedback = document.getElementById('feedback');
        const modal = document.getElementById('modal');
        const quizArea = document.getElementById('quiz-area');
        const actionBtn = document.getElementById('action-btn');
        const workingToggle = document.getElementById('toggle-working');
        const soundToggle = document.getElementById('toggle-sound');
        const arcadeTimerEl = document.getElementById('arcade-timer');
        const arcadeTimeDisplay = document.getElementById('arcade-time-display');
        const arcadeTimerFill = document.getElementById('arcade-timer-fill');

        const levelExplanationTitle = document.getElementById('level-explanation-title');
        const levelExplanationBody = document.getElementById('level-explanation-body');
        const sessionSummaryEl = document.getElementById('session-summary');
        const sessionLogContainer = document.getElementById('session-log-container');
        const sessionLogText = document.getElementById('session-log-text');
        const copyLogBtn = document.getElementById('copy-log-btn');

        const quizTimerEl = document.getElementById('quiz-timer');
        const quizTimeDisplay = document.getElementById('quiz-time-display');

        // --- WEB AUDIO SYNTH ENGINE ---

        let audioCtx = null;
        let audioReady = false;

        function initAudioContext() {
            if (audioReady) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) {
                console.warn('Web Audio API not supported, sound disabled.');
                soundEnabled = false;
                return;
            }
            audioCtx = new AC();
            audioReady = true;
            console.log('[audio] AudioContext initialised');
        }

        function makeGain(duration = 0.3, startGain = 0.3) {
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(startGain, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            gain.connect(audioCtx.destination);
            return gain;
        }

        function playNote(freq, type = 'sine', duration = 0.25, gainLevel = 0.25, delay = 0) {
            if (!audioReady || !soundEnabled) return;
            const osc = audioCtx.createOscillator();
            const gain = makeGain(duration, gainLevel);
            const startTime = audioCtx.currentTime + delay;
            osc.type = type;
            osc.frequency.setValueAtTime(freq, startTime);
            osc.connect(gain);
            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function playCorrectSound() {
            const C5 = 523.25;
            const E5 = 659.25;
            const G5 = 783.99;
            playNote(C5, 'sine', 0.18, 0.25, 0);
            playNote(E5, 'sine', 0.18, 0.25, 0.05);
            playNote(G5, 'sine', 0.18, 0.25, 0.10);
        }

        function playWrongSound() {
            if (!audioReady || !soundEnabled) return;
            const base = 110;
            const osc = audioCtx.createOscillator();
            const gain = makeGain(0.35, 0.35);
            const now = audioCtx.currentTime;
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(base, now);
            osc.frequency.setValueAtTime(base * 0.8, now + 0.2);
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.35);
        }

        function playLevelupSound() {
            const A4 = 440;
            const Csharp5 = 554.37;
            const E5 = 659.25;
            const A5 = 880;
            playNote(A4,      'triangle', 0.18, 0.25, 0);
            playNote(Csharp5, 'triangle', 0.18, 0.25, 0.07);
            playNote(E5,      'triangle', 0.18, 0.25, 0.14);
            playNote(A5,      'triangle', 0.22, 0.25, 0.22);
        }

        function playClickSound() {
            const freq = 1200;
            playNote(freq, 'square', 0.08, 0.18, 0);
        }

        function playSound(name) {
            if (!soundEnabled || !audioReady) return;
            switch (name) {
                case 'correct':
                    playCorrectSound();
                    break;
                case 'wrong':
                    playWrongSound();
                    break;
                case 'levelup':
                    playLevelupSound();
                    break;
                case 'click':
                    playClickSound();
                    break;
                default:
                    break;
            }
        }

        // --- UTILS ---

        let quizStarted = false;

        // simple shuffle for randomised exam-mode
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        // --- CORE FUNCTIONS ---

        function updateLevelExplanation() {
            const lvl = levels[currentLevel];
            if (!lvl) return;
            if (levelExplanationTitle) {
                levelExplanationTitle.textContent = `Level ${currentLevel + 1} ‚Äì ${lvl.name}`;
            }
            if (levelExplanationBody) {
                levelExplanationBody.innerHTML = `<strong>Algorithm:</strong> ${lvl.algorithm}<br>${lvl.theory}`;
            }
        }

        function initGrid() {
            gridEl.innerHTML = '';
            tableSize = levels[currentLevel].tableSize;

            memory = new Array(tableSize).fill(null);
            if (levels[currentLevel].mode === 'chaining') {
                for (let i = 0; i < tableSize; i++) {
                    memory[i] = [];
                }
            }

            for (let i = 0; i < tableSize; i++) {
                const slot = document.createElement('div');
                slot.className = 'memory-slot';
                slot.dataset.index = i;
                slot.setAttribute('role', 'gridcell');
                slot.setAttribute('aria-label', `Index ${i}`);
                slot.tabIndex = 0;

                slot.addEventListener('click', () => handleSlotClick(i));
                slot.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleSlotClick(i);
                    }
                });

                const indexLabel = document.createElement('div');
                indexLabel.className = 'slot-index';
                indexLabel.innerText = `Idx ${i}`;

                slot.appendChild(indexLabel);
                gridEl.appendChild(slot);
            }

            // Random chaining setup for Level 3
            if (levels[currentLevel].mode === 'chaining') {
                setupRandomChainingLevel();
            }

            // preload for search and dictionary
            if (levels[currentLevel].mode === 'search' || levels[currentLevel].mode === 'dictionary') {
                levels[currentLevel].preLoadedData.forEach(data => {
                    updateMemoryVisuals(data.index, data, { isPreloading: true });
                });
            }
        }

        // --- LEVEL 3: RANDOM CHAINING SETUP ---

        function setupRandomChainingLevel() {
            const lvl = levels[currentLevel];
            if (!lvl || lvl.mode !== 'chaining') return;

            const size = lvl.tableSize; // 13
            const chainIndices = [];

            // Pick 2 distinct random indices in [0, size-1]
            while (chainIndices.length < 2) {
                const candidate = Math.floor(Math.random() * size);
                if (!chainIndices.includes(candidate)) {
                    chainIndices.push(candidate);
                }
            }

            const cards = [];

            chainIndices.forEach(idx => {
                // Preload a small chain at this index (length 1‚Äì3)
                const initialLen = 1 + Math.floor(Math.random() * 3); // 1, 2 or 3
                for (let k = 0; k < initialLen; k++) {
                    const key = idx + size * k; // key = idx + 13*k
                    const rec = {
                        key,
                        value: `Preload idx ${idx}, k=${k}`
                    };
                    updateMemoryVisuals(idx, rec, { isPreloading: true });
                }

                // Generate cards that will extend this chain further
                const extraCards = 2 + Math.floor(Math.random() * 2); // 2 or 3 inserts per chain
                let nextK = initialLen;
                for (let step = 0; step < extraCards; step++) {
                    const k = nextK++;
                    const key = idx + size * k;
                    cards.push({
                        key,
                        value: `Data @ idx ${idx}, k=${k}`
                    });
                }
            });

            // Shuffle so the two chains are interleaved randomly
            shuffleArray(cards);
            lvl.cards = cards;
        }

        function updateArcadeTimerUI() {
            const seconds = Math.max(0, Math.ceil(arcadeTimeRemaining / 1000));
            arcadeTimeDisplay.textContent = seconds;
            const ratio = arcadeTimeLimit > 0 ? arcadeTimeRemaining / arcadeTimeLimit : 0;
            arcadeTimerFill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
        }

        function startArcadeMode() {
            const levelData = levels[currentLevel];
            arcadeActive = true;
            arcadeTimeLimit = levelData.timeLimitMs || 30000;
            arcadeTimeRemaining = arcadeTimeLimit;

            arcadeTimerEl.classList.remove('hidden');
            updateArcadeTimerUI();

            if (arcadeTimerInterval) {
                clearInterval(arcadeTimerInterval);
            }

            arcadeTimerInterval = setInterval(() => {
                arcadeTimeRemaining -= 1000;
                if (arcadeTimeRemaining <= 0) {
                    arcadeTimeRemaining = 0;
                    updateArcadeTimerUI();
                    endArcadeLevel();
                } else {
                    updateArcadeTimerUI();
                }
            }, 1000);

            generateArcadeCard();
        }

        function stopArcadeMode() {
            arcadeActive = false;
            if (arcadeTimerInterval) {
                clearInterval(arcadeTimerInterval);
                arcadeTimerInterval = null;
            }
            arcadeTimerEl.classList.add('hidden');
        }

        function endArcadeLevel() {
            if (!arcadeActive) return;
            stopArcadeMode();
            displayFeedback("Time up! Retro wave complete. Final arcade score: " + score, true);
            playSound('levelup');
            endLevel();
        }

        function generateArcadeCard() {
            const key = Math.floor(Math.random() * 90) + 10; // 10‚Äì99
            arcadeCurrentCard = {
                key,
                value: "üëæ Invader #" + key
            };
            // track arcade items and reaction start
            levelStats[currentLevel].itemsSeen++;
            levelStats[currentLevel].arcadeItems++;
            arcadeCardStartTime = performance.now();
            currentCardAttempts = 0;
            showCard();
        }

        function showCard() {
            const levelData = levels[currentLevel];
            if (levelData.mode === 'quiz') return;

            if (levelData.mode !== 'arcade' && currentCardIndex >= levelData.cards.length) {
                endLevel();
                return;
            }

            let cardData;
            if (levelData.mode === 'arcade') {
                cardData = arcadeCurrentCard;
            } else {
                cardData = levelData.cards[currentCardIndex];
                // track items seen and reset attempts for ‚Äúfirst-try‚Äù stats
                levelStats[currentLevel].itemsSeen++;
                currentCardAttempts = 0;
            }

            const mod = levelData.tableSize;
            const baseHash = cardData.key % mod;
            const division = Math.floor(cardData.key / mod);
            const remainder = baseHash;

            let workingHtml = "";
            if (showWorking) {
                workingHtml = `
                    <div class="data-card-working">
                        ${cardData.key} √∑ ${mod} = ${division} remainder ${remainder}<br>
                        ${cardData.key} % ${mod} = ${remainder}
                    </div>
                `;
            } else {
                const showHash = (levelData.mode === 'search' || levelData.mode === 'dictionary' || levelData.mode === 'arcade') ? baseHash : "?";
                workingHtml = `
                    <div class="data-card-working">
                        HASH: ${cardData.key} % ${mod} = ${showHash}
                    </div>
                `;
            }

            if (levelData.mode === 'search' || levelData.mode === 'dictionary') {
                const isDict = levelData.mode === 'dictionary';
                const mainLabel = isDict
                    ? `WORD: ${cardData.word}`
                    : `KEY: ${cardData.key}`;
                const subtitle = isDict
                    ? "Use the hash table as a dictionary: jump to the index and find the word‚Äôs definition."
                    : "Use the hash to jump to the starting index and locate the record.";

                cardArea.innerHTML = `
                    <div class="data-card" style="background: var(--highlight); color: #111;">
                        <div class="data-card-main">
                            <span style="font-size:0.8em;">FIND THIS ${isDict ? "WORD" : "KEY"}:</span><br>
                            ${mainLabel}
                        </div>
                        <div class="data-card-sub">
                            ${subtitle}
                        </div>
                        ${workingHtml}
                    </div>
                `;
            } else if (levelData.mode === 'arcade') {
                cardArea.innerHTML = `
                    <div class="data-card" style="background: #f38ba8; color: #111;">
                        <div class="data-card-main">
                            üëæ INVADER INCOMING<br>KEY: ${cardData.key}
                        </div>
                        <div class="data-card-sub">
                            Place the invader using Key MOD ${mod} with linear probing before time runs out!
                        </div>
                        ${workingHtml}
                    </div>
                `;
            } else if (levelData.mode === 'chaining') {
                const chainIndex = baseHash;
                const currentLen = memory[chainIndex] ? memory[chainIndex].length : 0;

                cardArea.innerHTML = `
                    <div class="data-card">
                        <div class="data-card-main">KEY: ${cardData.key}</div>
                        <div class="data-card-sub">
                            Target chain index: ${chainIndex}<br>
                            Current chain length: ${currentLen}
                        </div>
                        ${workingHtml}
                    </div>
                `;
            } else {
                cardArea.innerHTML = `
                    <div class="data-card">
                        <div class="data-card-main">KEY: ${cardData.key}</div>
                        <div class="data-card-sub">${cardData.value}</div>
                        ${workingHtml}
                    </div>
                `;
            }
        }

        function pulseSlot(index, isCorrect) {
            const slotEl = gridEl.children[index];
            const className = isCorrect ? 'slot-pulse-correct' : 'slot-pulse-wrong';
            slotEl.classList.add(className);
            setTimeout(() => {
                slotEl.classList.remove(className);
            }, 450);
        }

        function highlightProbePath(pathIndices) {
            pathIndices.forEach((idx, step) => {
                const slotEl = gridEl.children[idx];
                setTimeout(() => {
                    slotEl.classList.add('slot-probe-path');
                    setTimeout(() => slotEl.classList.remove('slot-probe-path'), 400);
                }, step * 120);
            });
        }

        function handleSlotClick(clickedIndex) {
            const levelData = levels[currentLevel];
            if (levelData.mode === 'quiz') return;

            const stats = levelStats[currentLevel];

            const currentCard = (levelData.mode === 'arcade')
                ? arcadeCurrentCard
                : levelData.cards[currentCardIndex];

            const mod = levelData.tableSize;
            const rawHash = currentCard.key % mod;

            // attempt count for this card
            currentCardAttempts++;

            let correctIndex = -1;
            let success = false;
            let msg = "Incorrect.";

            if (levelData.mode === 'search' || levelData.mode === 'dictionary') {
                const isDict = levelData.mode === 'dictionary';
                correctIndex = currentCard.index;

                if (clickedIndex === correctIndex) {
                    success = true;
                    if (isDict) {
                        msg = `SUCCESS! Word "${currentCard.word}" found at index ${correctIndex}. This is exactly how a dictionary lookup works.`;
                    } else {
                        msg = `SUCCESS! Key ${currentCard.key} found at Index ${correctIndex}. Lookup: O(1) on average.`;
                    }
                    score += 15;
                    playSound('correct');
                    stats.slotCorrect++;
                    if (currentCardAttempts === 1) stats.firstTryCorrect++;
                } else {
                    if (isDict) {
                        msg = `Not quite. "${currentCard.word}" is not stored at index ${clickedIndex}. ` +
                              `Conceptually, hash(word) gives a starting index (here ${rawHash}), then you follow the table from there.`;
                    } else {
                        msg = `Key not found at Index ${clickedIndex}. Start from hash ${rawHash} and follow the table.`;
                    }
                    score = Math.max(0, score - 5);
                    playSound('wrong');
                    stats.slotIncorrect++;
                }
            } else {
                if (levelData.mode === 'basic') {
                    correctIndex = rawHash;
                } else if (levelData.mode === 'probing' || levelData.mode === 'arcade') {
                    let probe = rawHash;
                    let loopGuard = 0;
                    while (memory[probe] !== null && loopGuard < mod + 1) {
                        probe = (probe + 1) % mod;
                        loopGuard++;
                    }
                    correctIndex = probe;

                    const path = [];
                    let idx = rawHash;
                    while (true) {
                        path.push(idx);
                        if (idx === correctIndex) break;
                        idx = (idx + 1) % mod;
                    }
                    highlightProbePath(path);
                } else if (levelData.mode === 'chaining') {
                    correctIndex = rawHash;
                }

                if (clickedIndex === correctIndex) {
                    success = true;
                    score += (levelData.mode === 'arcade') ? 15 : 10;

                    if (levelData.mode === 'chaining') {
                        const oldLen = memory[correctIndex] ? memory[correctIndex].length : 0;
                        updateMemoryVisuals(clickedIndex, currentCard);
                        const newLen = oldLen + 1;
                        msg = `Correct! Chain at index ${correctIndex}: length ${oldLen} \u2192 ${newLen}.`;
                    } else {
                        updateMemoryVisuals(clickedIndex, currentCard);
                        msg = levelData.mode === 'arcade'
                            ? "Nice shot! Invader stored."
                            : "Correct allocation!";
                    }

                    playSound('correct');
                    stats.slotCorrect++;
                    if (currentCardAttempts === 1) stats.firstTryCorrect++;

                    // record arcade reaction time
                    if (levelData.mode === 'arcade' && arcadeCardStartTime != null) {
                        const dt = performance.now() - arcadeCardStartTime;
                        stats.arcadeTotalTimeMs += dt;
                        arcadeCardStartTime = null;
                    }
                } else {
                    score = Math.max(0, score - 5);
                    if (levelData.mode === 'basic') {
                        msg = `Wrong! ${currentCard.key} % ${mod} = ${rawHash}.`;
                    } else if (levelData.mode === 'probing' || levelData.mode === 'arcade') {
                        msg = `Collision resolution needed. Start at ${rawHash} and probe to the next empty slot (Index ${correctIndex}).`;
                    } else if (levelData.mode === 'chaining') {
                        msg = `Wrong! In chaining, always store at the hashed index (${rawHash}) and add to the list.`;
                    }
                    playSound('wrong');
                    stats.slotIncorrect++;
                }
            }

            // log event
            sessionEvents.push({
                timestamp: Date.now(),
                level: currentLevel + 1,
                mode: levelData.mode,
                event: 'slotClick',
                key: currentCard.key,
                word: currentCard.word || null,
                clickedIndex,
                correctIndex,
                correct: success,
                attemptNumber: currentCardAttempts,
                scoreAfter: score
            });

            pulseSlot(clickedIndex, success);
            displayFeedback(msg, success);
            updateScore();

            if (success) {
                if (levelData.mode === 'arcade') {
                    generateArcadeCard();
                } else {
                    currentCardIndex++;
                    showCard();
                }
            }
        }

        function renderStoredKey(slotEl, card, { faded }) {
            const item = document.createElement('div');
            item.className = 'stored-item';
            item.innerText = card.key;
            if (faded) {
                item.style.backgroundColor = 'var(--slot-bg)';
                item.style.color = 'var(--highlight)';
            }
            slotEl.appendChild(item);
        }

        function updateMemoryVisuals(index, card, options = {}) {
            const { isPreloading = false } = options;
            const levelData = levels[currentLevel];
            const slotEl = gridEl.children[index];

            if (levelData.mode === 'chaining') {
                memory[index].push(card);
                if (memory[index].length > 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'linked-arrow';
                    arrow.innerHTML = '&#8595;';
                    slotEl.appendChild(arrow);
                }
                renderStoredKey(slotEl, card, { faded: false });
                return;
            }

            if ((levelData.mode === 'search' || levelData.mode === 'dictionary') && isPreloading) {
                memory[index] = card;
                renderStoredKey(slotEl, card, { faded: true });
                return;
            }

            memory[index] = card;
            renderStoredKey(slotEl, card, { faded: false });
        }

        function displayFeedback(msg, isSuccess) {
            feedback.innerText = msg;
            feedback.style.color = isSuccess ? "var(--success)" : "var(--error)";
            setTimeout(() => {
                if (feedback.innerText === msg) {
                    feedback.innerText = "";
                }
            }, 4000);
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
        }

        // --- QUIZ LOGIC (BOSS LEVEL, 30s PER QUESTION, SUDDEN DEATH) ---

        function updateQuizTimerUI() {
            const seconds = Math.max(0, Math.ceil(quizTimeRemaining / 1000));
            quizTimeDisplay.textContent = seconds;
        }

        function startQuizTimer() {
            quizTimeLimitMs = 30000; // 30 seconds per question
            quizTimeRemaining = quizTimeLimitMs;
            quizTimerEl.classList.remove('hidden');
            updateQuizTimerUI();

            if (quizTimerInterval) {
                clearInterval(quizTimerInterval);
            }

            quizTimerInterval = setInterval(() => {
                quizTimeRemaining -= 1000;
                if (quizTimeRemaining <= 0) {
                    quizTimeRemaining = 0;
                    updateQuizTimerUI();
                    stopQuizTimer();
                    handleQuizTimeout(); // sudden death
                } else {
                    updateQuizTimerUI();
                }
            }, 1000);
        }

        function stopQuizTimer() {
            if (quizTimerInterval) {
                clearInterval(quizTimerInterval);
                quizTimerInterval = null;
            }
            quizTimerEl.classList.add('hidden');
        }

        function startQuiz() {
            currentQuizIndex = 0;
            quizLocked = false;
            quizStarted = true;
            shuffleArray(examQuestions);
            renderQuestion(); // renderQuestion will start the per-question timer
            playSound('levelup');
        }

        function renderQuestion() {
            if (currentQuizIndex >= examQuestions.length) {
                shuffleArray(examQuestions);
                currentQuizIndex = 0;
            }

            const q = examQuestions[currentQuizIndex];

            let html = `
                <div class="quiz-question">Q${currentQuizIndex + 1}: ${q.q}</div>
                <div class="quiz-options">
                    ${q.options.map((opt, idx) =>
                        `<button type="button" class="quiz-option" data-index="${idx}">${opt}</button>`
                    ).join('')}
                </div>
                <div id="quiz-explanation" class="quiz-explanation hidden"></div>
                <button id="quiz-next-btn" type="button" class="start-btn quiz-next-btn" disabled>Next Question</button>
            `;

            quizArea.innerHTML = html;
            quizArea.classList.remove('hidden');
            quizLocked = false;

            // Start / restart the per-question timer
            startQuizTimer();
        }

        function handleQuizAnswer(selectedIdx) {
            if (quizLocked) return;
            quizLocked = true;

            // Stop timer ‚Äì they‚Äôve committed to an answer
            stopQuizTimer();

            const q = examQuestions[currentQuizIndex];
            const opts = quizArea.querySelectorAll('.quiz-option');
            const stats = levelStats[currentLevel];

            opts.forEach(o => {
                o.disabled = true;
            });

            const correctIdx = q.answer;
            let success = false;

            if (selectedIdx === correctIdx) {
                success = true;
                opts[selectedIdx].classList.add('correct');
                score += 20;
                stats.quizCorrect++;
                displayFeedback("Correct!", true);
                playSound('correct');
            } else {
                opts[selectedIdx].classList.add('wrong');
                opts[correctIdx].classList.add('correct');
                score = Math.max(0, score - 10);
                stats.quizIncorrect++;
                displayFeedback("Incorrect.", false);
                playSound('wrong');
            }
            updateScore();

            // log quiz event
            sessionEvents.push({
                timestamp: Date.now(),
                level: currentLevel + 1,
                mode: 'quiz',
                event: 'quizAnswer',
                questionIndex: currentQuizIndex,
                selectedIndex: selectedIdx,
                correctIndex: correctIdx,
                correct: success,
                scoreAfter: score
            });

            const expEl = document.getElementById('quiz-explanation');
            if (expEl) {
                expEl.textContent = "Explanation: " + q.explanation;
                expEl.classList.remove('hidden');
            }

            const nextBtn = document.getElementById('quiz-next-btn');
            if (nextBtn) {
                nextBtn.disabled = false;
            }
        }

        function goToNextQuestion() {
            currentQuizIndex++;
            renderQuestion();
        }

        function handleQuizTimeout() {
            if (quizLocked) return;
            quizLocked = true;

            const q = examQuestions[currentQuizIndex];
            const stats = levelStats[currentLevel];
            stats.quizIncorrect++;

            score = Math.max(0, score - 10);
            updateScore();

            const opts = quizArea.querySelectorAll('.quiz-option');
            opts.forEach((btn, idx) => {
                btn.disabled = true;
                if (idx === q.answer) {
                    btn.classList.add('correct');
                }
            });

            const expEl = document.getElementById('quiz-explanation');
            if (expEl) {
                expEl.textContent = "Time's up! " + q.explanation;
                expEl.classList.remove('hidden');
            }

            displayFeedback("Time's up! That question counts as incorrect. Session over.", false);
            playSound('wrong');

            sessionEvents.push({
                timestamp: Date.now(),
                level: currentLevel + 1,
                mode: 'quiz',
                event: 'quizTimeout',
                questionIndex: currentQuizIndex,
                correctIndex: q.answer,
                correct: false,
                scoreAfter: score
            });

            // Sudden-death: show full session summary now
            showFinalSummary();
        }

        // --- FLOW CONTROL ---

        function startGame() {
            try {
                stopArcadeMode();
                stopQuizTimer();
                modal.classList.add('hidden');

                document.getElementById('level-display').innerText = currentLevel + 1;
                document.getElementById('mode-name').innerText = levels[currentLevel].name;
                updateLevelExplanation();

                const levelData = levels[currentLevel];

                // log level start
                sessionEvents.push({
                    timestamp: Date.now(),
                    level: currentLevel + 1,
                    mode: levelData.mode,
                    event: 'levelStart'
                });

                if (levelData.mode === 'quiz') {
                    gridEl.innerHTML =
                        '<div style="grid-column: 1/-1; text-align: center; padding: 50px; color: var(--accent); font-size: 1.6em; opacity:0.6;">THEORY MODE ACTIVE</div>';
                    cardArea.innerHTML =
                        '<div style="color:#fff; font-size:0.95em;">Calculating Theory Knowledge...</div>';

                    modal.classList.remove('hidden');
                    document.getElementById('modal-title').innerText = "BOSS LEVEL";
                    document.getElementById('modal-desc').innerText = "30-second sudden-death exam drill";
                    document.getElementById('modal-theory').innerHTML =
                        "You get 30 seconds per question. Correct answers gain points, wrong answers lose points. " +
                        "If the timer hits zero on any question, that question is marked wrong and the session summary appears immediately.";

                    quizArea.classList.remove('hidden');
                    actionBtn.classList.add('hidden');
                    startQuiz();
                } else if (levelData.mode === 'arcade') {
                    initGrid();
                    startArcadeMode();
                    playSound('levelup');
                } else {
                    initGrid();
                    currentCardIndex = 0;
                    showCard();
                    playSound('levelup');
                }
            } catch (e) {
                alert("Error starting game: " + e.message + "\nCheck browser console for details.");
                console.error(e);
            }
        }

        function buildLevelSummaryText() {
            const lines = [];
            levels.forEach((lvl, idx) => {
                const stats = levelStats[idx];
                const totalAttempts = stats.slotCorrect + stats.slotIncorrect;
                const ft = stats.firstTryCorrect;
                const ftText = totalAttempts > 0
                    ? `${ft}/${stats.itemsSeen || totalAttempts} first-try correct`
                    : "No slot questions attempted";

                let arcadeText = "";
                if (stats.arcadeItems > 0 && stats.arcadeTotalTimeMs > 0) {
                    const avgMs = stats.arcadeTotalTimeMs / stats.arcadeItems;
                    const avgSecs = (avgMs / 1000).toFixed(2);
                    arcadeText = ` | Arcade avg time/card: ${avgSecs}s`;
                }

                const quizTotal = stats.quizCorrect + stats.quizIncorrect;
                const quizText = quizTotal > 0
                    ? ` | Quiz: ${stats.quizCorrect}/${quizTotal} correct`
                    : "";

                lines.push(
                    `<li><strong>Level ${idx + 1}: ${lvl.name}</strong><br>` +
                    `Slot tasks: ${stats.slotCorrect}/${totalAttempts} correct (${ftText})${arcadeText}${quizText}</li>`
                );
            });
            return `<ul>${lines.join('')}</ul>`;
        }

        function showFinalSummary() {
            stopArcadeMode();
            stopQuizTimer();

            document.getElementById('modal-title').innerText = "Session Summary";
            document.getElementById('modal-desc').innerText = `Total score: ${score}`;

            const summaryHtml = `
                <p>Use this to drive revision: look for levels with lower first-try accuracy or slower arcade reactions.</p>
                ${buildLevelSummaryText()}
            `;
            sessionSummaryEl.innerHTML = summaryHtml;
            sessionSummaryEl.classList.remove('hidden');

            // JSON export
            const logString = JSON.stringify(sessionEvents, null, 2);
            sessionLogText.value = logString;
            sessionLogContainer.classList.remove('hidden');

            document.getElementById('modal-theory').innerHTML =
                "<strong>Teaching tip:</strong> Use the stats and JSON log to discuss collisions, probing, and lookup behaviour with the class.";

            actionBtn.classList.remove('hidden');
            actionBtn.innerText = "Restart session";
            actionBtn.dataset.action = "reset";

            modal.classList.remove('hidden');
        }

        function endLevel() {
            stopArcadeMode();
            stopQuizTimer();

            currentLevel++;
            if (currentLevel < levels.length) {
                document.getElementById('modal-title').innerText = `Level ${currentLevel} Complete`;
                document.getElementById('modal-desc').innerText = `Next up: ${levels[currentLevel].name}`;
                document.getElementById('modal-theory').innerHTML =
                    `<strong>New Rule:</strong> ${levels[currentLevel].theory}`;

                currentCardIndex = 0;
                actionBtn.innerText = "Start Next Level";
                actionBtn.classList.remove('hidden');
                actionBtn.dataset.action = "start";
                quizArea.classList.add('hidden');
                sessionSummaryEl.classList.add('hidden');
                sessionLogContainer.classList.add('hidden');

                modal.classList.remove('hidden');
                actionBtn.focus();
                playSound('levelup');
            } else {
                // final end-of-session summary
                showFinalSummary();
            }
        }

        // --- SAFE INITIALIZATION ---

        document.addEventListener('DOMContentLoaded', function () {
            actionBtn.addEventListener('click', () => {
                // Initialise Web Audio on first click
                initAudioContext();

                const mode = actionBtn.dataset.action;
                if (audioReady && soundEnabled) {
                    playClickSound();
                }
                if (mode === "start") {
                    startGame();
                } else if (mode === "reset") {
                    location.reload();
                }
            });

            if (workingToggle) {
                workingToggle.addEventListener('change', (e) => {
                    showWorking = e.target.checked;
                    const lvl = levels[currentLevel];
                    if (lvl.mode !== 'quiz') {
                        showCard();
                    }
                });
            }

            if (soundToggle) {
                soundToggle.addEventListener('change', (e) => {
                    soundEnabled = e.target.checked;
                    if (soundEnabled && audioReady) playClickSound();
                });
            }

            quizArea.addEventListener('click', (e) => {
                const option = e.target.closest('.quiz-option');
                if (option) {
                    const idx = Number(option.dataset.index);
                    if (!Number.isNaN(idx)) {
                        handleQuizAnswer(idx);
                    }
                    return;
                }

                const nextBtn = e.target.closest('#quiz-next-btn');
                if (nextBtn && !nextBtn.disabled) {
                    if (audioReady && soundEnabled) playClickSound();
                    goToNextQuestion();
                }
            });

            // copy session log button
            if (copyLogBtn) {
                copyLogBtn.addEventListener('click', () => {
                    try {
                        sessionLogText.select();
                        document.execCommand('copy');
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(sessionLogText.value);
                        }
                        displayFeedback("Session log copied to clipboard.", true);
                    } catch (err) {
                        displayFeedback("Could not copy log, but you can manually select the JSON.", false);
                        console.error(err);
                    }
                });
            }

            // Initial explanation for level 1
            updateLevelExplanation();
        });
    </script>
</body>
</html>
