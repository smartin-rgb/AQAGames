<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hash-Crash Scheduler: Final Edition</title>
    <style>
        :root {
            --bg-color: #1e1e2e;
            --card-bg: #313244;
            --slot-bg: #45475a;
            --accent: #89b4fa;
            --success: #a6e3a1;
            --error: #f38ba8;
            --text: #cdd6f4;
            --highlight: #f9e2af;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        header { text-align: center; margin: 20px 0; }
        h1 { color: var(--accent); margin-bottom: 5px; font-size: 1.8rem; }
        .subtitle { font-size: 0.9em; opacity: 0.8; }

        #game-container {
            width: 90%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Info Panel */
        #info-panel {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        /* Current Data Card */
        #current-card-area {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 120px;
            background: #181825;
            border-radius: 8px;
            border: 2px dashed var(--text);
            margin-bottom: 20px;
        }

        .data-card {
            background: var(--accent);
            color: #111;
            padding: 15px 30px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: popIn 0.3s ease;
            text-align: center;
            min-width: 200px;
        }

        @keyframes popIn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        /* Memory Grid */
        #memory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-bottom: 40px;
        }

        .memory-slot {
            background: var(--slot-bg);
            border: 2px solid #585b70;
            border-radius: 5px;
            min-height: 100px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .memory-slot:hover {
            border-color: var(--accent);
            background: #585b70;
            transform: translateY(-2px);
        }
        
        /* New Pulse Feedback */
        .slot-pulse-correct {
            animation: pulse-correct 0.4s ease-out;
        }

        .slot-pulse-wrong {
            animation: pulse-wrong 0.4s ease-out;
        }

        @keyframes pulse-correct {
            0% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(166, 227, 161, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(166, 227, 161, 0); }
        }

        @keyframes pulse-wrong {
            0% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0.7); }
            50% { box-shadow: 0 0 10px 10px rgba(243, 139, 168, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(243, 139, 168, 0); }
        }


        .slot-index {
            font-size: 0.8em;
            color: #9399b2;
            margin-bottom: 5px;
            border-bottom: 1px solid #9399b2;
            width: 100%;
            text-align: center;
        }

        .stored-item {
            background: var(--accent);
            color: #111;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-top: 2px;
            width: 90%;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .linked-arrow {
            color: var(--text);
            font-size: 0.8em;
        }

        /* Feedback Area */
        #feedback {
            text-align: center;
            height: 30px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        /* Modal */
        #modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            text-align: center;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px rgba(137, 180, 250, 0.2);
        }

        .start-btn {
            background: var(--accent);
            color: #1e1e2e;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: 900;
            transition: transform 0.1s;
        }

        .start-btn:hover {
            transform: scale(1.05);
        }

        .hidden { display: none !important; }

        /* Quiz Styles */
        .quiz-container {
            text-align: left;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .quiz-question {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: var(--highlight);
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quiz-option {
            background: var(--slot-bg);
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #585b70;
            transition: background 0.2s;
        }
        .quiz-option:hover {
            background: #585b70;
        }
        .quiz-option.correct {
            background: var(--success);
            color: #111;
            border-color: var(--success);
        }
        .quiz-option.wrong {
            background: var(--error);
            color: #111;
            border-color: var(--error);
        }

    </style>
</head>
<body>

    <header>
        <h1>The Hash-Crash Scheduler</h1>
        <div class="subtitle">AQA A-Level Computer Science: Enhanced Edition</div>
    </header>

    <div id="game-container">
        <div id="info-panel">
            <div>Level: <span id="level-display">1</span></div>
            <div>Mode: <span id="mode-name" style="color: var(--highlight);">Basic Hashing</span></div>
            <div>Score: <span id="score">0</span></div>
        </div>

        <div id="current-card-area"></div>

        <div id="feedback"></div>

        <div id="memory-grid"></div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2 id="modal-title">Welcome, Controller</h2>
            <p id="modal-desc">You are responsible for storing data records efficiently.</p>
            
            <div id="modal-theory" style="background: #181825; padding: 15px; margin: 15px 0; font-size: 0.95em; text-align: left; border-left: 4px solid var(--highlight);">
                <strong>Mission:</strong> Calculate the correct index using the hashing algorithm and click the memory slot to store the data.
            </div>
            
            <div id="quiz-area" class="hidden quiz-container"></div>

            <button id="action-btn" class="start-btn">START LEVEL 1</button>
        </div>
    </div>

    <script>
        // --- GAME CONFIGURATION & DATA ---
        
        // Level Definitions
        const levels = [
            {
                name: "The Perfect Hash",
                algorithm: "Index = Key MOD 11",
                theory: "A hashing algorithm calculates an index from the key. Ideally, every key maps to a unique slot.",
                mode: "basic", 
                tableSize: 11,
                cards: [
                    { key: 22, value: "User A" }, // 0
                    { key: 45, value: "User B" }, // 1
                    { key: 14, value: "User C" }, // 3
                    { key: 53, value: "User D" }, // 9
                    { key: 10, value: "User E" }  // 10
                ]
            },
            {
                name: "Collision (Rehashing)",
                algorithm: "Index = Key MOD 11 (Linear Probing)",
                theory: "When a collision occurs (slot occupied), Rehashing looks for the next empty slot (Linear Probing).",
                mode: "probing", 
                tableSize: 11,
                cards: [
                    { key: 33, value: "Rec 1" }, // 33%11 = 0
                    { key: 11, value: "Rec 2" }, // 11%11 = 0 -> Collision -> 1
                    { key: 56, value: "Rec 3" }, // 56%11 = 1 -> Collision -> 2
                    { key: 23, value: "Rec 4" }, // 23%11 = 1 -> Collision -> 3
                ]
            },
            {
                name: "The Chain Gang (Chaining)",
                algorithm: "Index = Key MOD 13 (Add to List)", // *** TABLE SIZE CHANGED TO 13 ***
                theory: "Chaining uses a linked list at each slot. If a collision occurs, simply add the new item to the list at that index. The table size is now 13.",
                mode: "chaining", 
                tableSize: 13,
                cards: [
                    { key: 25, value: "Data X" }, // 25%13 = 12
                    { key: 38, value: "Data Y" }, // 38%13 = 12 (List)
                    { key: 51, value: "Data Z" }  // 51%13 = 12 (List)
                ]
            },
            {
                name: "Search & Retrieval (O(1))",
                algorithm: "Index = Key MOD 11",
                theory: "The core benefit of hashing is quick retrieval. Use the algorithm (Key MOD 11) to find the location of the key. Retrieval is O(1) if successful.",
                mode: "search",
                tableSize: 11,
                // Data pre-loaded into the table before search begins
                preLoadedData: [
                    { key: 11, index: 0, value: "Rec A" }, 
                    { key: 45, index: 1, value: "Rec B" }, 
                    { key: 22, index: 2, value: "Rec C" }, 
                    { key: 8, index: 8, value: "Rec D" }, 
                ],
                // Keys the student must search for
                cards: [
                    { key: 45, value: "Rec B", index: 1 }, 
                    { key: 22, value: "Rec C", index: 2 }, 
                    { key: 8, value: "Rec D", index: 8 } 
                ]
            },
            {
                name: "BOSS LEVEL: EXAM SIMULATOR",
                algorithm: "A-Level Theory",
                theory: "Put down the cards. It's time to test your knowledge against the AQA specification.",
                mode: "quiz", 
                tableSize: 11,
                cards: [] 
            }
        ];

        // Exam Questions
        const examQuestions = [
            {
                q: "A collision occurs when two keys generate the same index. Which method solves this by searching for the next empty slot?",
                options: ["Chaining", "Rehashing (Linear Probing)", "Dictionary Mapping", "Normalisation"],
                answer: 1,
                explanation: "Rehashing (specifically linear probing) involves looking for the next available slot when a collision occurs."
            },
            {
                q: "Which of the following is NOT a typical application of a Hash Table?",
                options: ["Database Indexing", "Memory Addressing", "Sorting a list alphabetically", "Encryption"],
                answer: 2,
                explanation: "Hash tables are used for quick lookups (databases, caches) and encryption. They are NOT used for sorting data order."
            },
            {
                q: "Calculate the Index for Key 47 if the table size is 11. Algorithm: Key MOD 11.",
                options: ["Index 1", "Index 4", "Index 3", "Index 7"],
                answer: 2,
                explanation: "47 divided by 11 is 4 with a remainder of 3. (4*11 = 44, 47-44 = 3)."
            },
            {
                q: "What is 'Clustering' in the context of Hash Tables?",
                options: ["When data is encrypted securely", "When a hashing algorithm produces indices that are not randomly distributed", "When a table has no collisions", "When using a Dictionary"],
                answer: 1,
                explanation: "Clustering happens when an algorithm fails to spread data uniformly, causing items to bunch up and increasing collisions."
            },
            {
                q: "Which data structure maps a unique Key to a Value, similar to a real-life dictionary?",
                options: ["Queue", "Stack", "Associative Array (Dictionary)", "Linked List"],
                answer: 2,
                explanation: "A Dictionary (or Associative Array) maps a unique Key to a Value. A hash table is often used to implement this."
            }
        ];

        // --- GAME STATE & DOM REFERENCES ---
        let currentLevel = 0;
        let score = 0;
        let currentCardIndex = 0;
        let currentQuizIndex = 0;
        let memory = []; // Array size determined dynamically by level
        let tableSize = 11;

        const gridEl = document.getElementById('memory-grid');
        const cardArea = document.getElementById('current-card-area');
        const feedback = document.getElementById('feedback');
        const modal = document.getElementById('modal');
        const quizArea = document.getElementById('quiz-area');
        const actionBtn = document.getElementById('action-btn');

        // --- CORE FUNCTIONS ---

        function initGrid() {
            gridEl.innerHTML = '';
            tableSize = levels[currentLevel].tableSize;

            // Reset memory array based on table size and mode
            memory = new Array(tableSize).fill(null); 
            if(levels[currentLevel].mode === 'chaining') {
                for(let i=0; i<tableSize; i++) memory[i] = [];
            }

            // Set grid columns dynamically for better display of Mod 13
            gridEl.style.gridTemplateColumns = `repeat(auto-fit, minmax(calc(800px / ${tableSize}), 1fr))`;

            // Generate Slots
            for (let i = 0; i < tableSize; i++) {
                const slot = document.createElement('div');
                slot.className = 'memory-slot';
                slot.dataset.index = i;
                slot.onclick = () => handleSlotClick(i); 
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'slot-index';
                indexLabel.innerText = `Idx ${i}`;
                
                slot.appendChild(indexLabel);
                gridEl.appendChild(slot);
            }
            
            // Pre-load data if in search mode
            if (levels[currentLevel].mode === 'search') {
                levels[currentLevel].preLoadedData.forEach(data => {
                    updateMemoryVisuals(data.index, data, true); // true = is preloading
                });
            }
        }

        function showCard() {
            const levelData = levels[currentLevel];
            
            if (levelData.mode === 'quiz') return;

            if (currentCardIndex >= levelData.cards.length) {
                endLevel();
                return;
            }

            const cardData = levelData.cards[currentCardIndex];
            const mod = levelData.tableSize;
            
            let cardContent = `<div>KEY: ${cardData.key}</div>`;
            let instruction;

            if (levelData.mode === 'search') {
                // Search mode must show the hash result for quick retrieval
                const hash = cardData.key % mod;
                instruction = `HASH: ${cardData.key} % ${mod} = ${hash}`;

                cardArea.innerHTML = `
                    <div class="data-card" style="background: ${getComputedStyle(document.documentElement).getPropertyValue('--highlight')}; color: #111;">
                        <span style="font-size:0.8em;">FIND THIS KEY:</span>
                        ${cardContent}
                        <div style="font-size:0.6em; background:rgba(0,0,0,0.3); margin-top:5px; padding:2px;">${instruction}</div>
                    </div>`;
            } else {
                // *** IMPLEMENTATION: Hiding the hash result to force manual calculation ***
                instruction = `HASH: ${cardData.key} % ${mod} = ?`;

                cardArea.innerHTML = `
                    <div class="data-card">
                        ${cardContent}
                        <div style="font-size:0.6em; font-weight:normal; margin-top:5px;">${cardData.value}</div>
                        <div style="font-size:0.6em; background:rgba(0,0,0,0.3); margin-top:5px; padding:2px;">${instruction}</div>
                    </div>`;
            }
        }

        function pulseSlot(index, isCorrect) {
            const slotEl = gridEl.children[index];
            const className = isCorrect ? 'slot-pulse-correct' : 'slot-pulse-wrong';
            slotEl.classList.add(className);
            setTimeout(() => {
                slotEl.classList.remove(className);
            }, 500);
        }

        function handleSlotClick(clickedIndex) {
            const levelData = levels[currentLevel];
            if (levelData.mode === 'quiz') return;

            const currentCard = levelData.cards[currentCardIndex];
            const mod = levelData.tableSize;
            const rawHash = currentCard.key % mod; 
            let correctIndex = -1;
            let success = false;
            let msg = "Incorrect.";

            // --- LOGIC ENGINE ---
            if (levelData.mode === 'search') {
                // In search mode, the correct index is the one where the item was pre-loaded (handle collisions if present)
                correctIndex = currentCard.index; // This is the final location of the data
                
                if (clickedIndex === correctIndex) {
                    success = true;
                    msg = `SUCCESS! Key ${currentCard.key} retrieved instantly at Index ${correctIndex}. O(1) Time!`;
                    score += 15;
                } else {
                    msg = `Key not found at Index ${clickedIndex}. The key's hash is ${rawHash}.`;
                    score = Math.max(0, score - 5);
                }
            } 
            else { // Insertion modes (basic, probing, chaining)
                if (levelData.mode === 'basic') {
                    correctIndex = rawHash;
                } 
                else if (levelData.mode === 'probing') {
                    let probe = rawHash;
                    let loopGuard = 0;
                    while (memory[probe] !== null && loopGuard < mod + 1) {
                        probe = (probe + 1) % mod; 
                        loopGuard++;
                    }
                    correctIndex = probe;
                } 
                else if (levelData.mode === 'chaining') {
                    correctIndex = rawHash;
                }

                // --- VALIDATION ---
                if (clickedIndex === correctIndex) {
                    success = true;
                    score += 10;
                    msg = "Correct Allocation!";
                    updateMemoryVisuals(clickedIndex, currentCard);
                } else {
                    score = Math.max(0, score - 5);
                    if (levelData.mode === 'basic') msg = `Wrong! ${currentCard.key} % ${mod} = ${rawHash}`;
                    if (levelData.mode === 'probing') msg = `Collision! You must probe to the next EMPTY slot (Index ${correctIndex}).`;
                    if (levelData.mode === 'chaining') msg = `Wrong! In Chaining, stick to the calculated index (${rawHash}) even if full.`;
                }
            }
            
            // --- AFTERMATH ---
            pulseSlot(clickedIndex, success);
            displayFeedback(msg, success);
            updateScore();
            
            if (success) {
                currentCardIndex++;
                showCard();
            }
        }

        function updateMemoryVisuals(index, card, isPreloading = false) {
            const slotEl = gridEl.children[index];
            const levelData = levels[currentLevel];

            if (levelData.mode === 'chaining' || (levelData.mode === 'search' && isPreloading)) {
                if (levelData.mode === 'chaining') {
                    memory[index].push(card);
                } else if (levels[currentLevel].mode === 'search' && isPreloading) {
                    memory[index] = card; 
                }
                
                if (levels[currentLevel].mode === 'chaining' && memory[index].length > 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'linked-arrow';
                    arrow.innerHTML = '&#8595;'; 
                    slotEl.appendChild(arrow);
                }
                
                const item = document.createElement('div');
                item.className = 'stored-item';
                item.innerText = card.key;
                slotEl.appendChild(item);
                
                if (isPreloading) {
                    // Ensure pre-loaded items are visibly faded or different
                    item.style.backgroundColor = 'var(--slot-bg)';
                    item.style.color = 'var(--highlight)';
                }

            } else {
                memory[index] = card;
                const item = document.createElement('div');
                item.className = 'stored-item';
                item.innerText = card.key;
                slotEl.appendChild(item);
            }
        }

        function displayFeedback(msg, isSuccess) {
            feedback.innerText = msg;
            feedback.style.color = isSuccess ? "var(--success)" : "var(--error)";
            setTimeout(() => feedback.innerText = "", 3000);
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
        }

        // --- QUIZ LOGIC (Unchanged) ---

        function startQuiz() {
            currentQuizIndex = 0;
            renderQuestion();
        }

        function renderQuestion() {
            if (currentQuizIndex >= examQuestions.length) {
                document.getElementById('modal-title').innerText = "Assessment Complete";
                document.getElementById('modal-desc').innerText = `Final Score: ${score}`;
                document.getElementById('modal-theory').innerHTML = "You have mastered Hash Tables, Collisions, and Dictionaries.";
                quizArea.classList.add('hidden');
                
                actionBtn.classList.remove('hidden');
                actionBtn.innerText = "Reset System";
                actionBtn.removeEventListener('click', startGame);
                actionBtn.addEventListener('click', () => location.reload());
                return;
            }

            const q = examQuestions[currentQuizIndex];
            let html = `<div class="quiz-question">Q${currentQuizIndex+1}: ${q.q}</div><div class="quiz-options">`;
            
            q.options.forEach((opt, idx) => {
                html += `<div class="quiz-option" id="opt-${idx}" onclick="handleQuizAnswer(${idx})">${opt}</div>`;
            });
            html += `</div>`;

            quizArea.innerHTML = html;
        }

        window.handleQuizAnswer = function(selectedIdx) {
            const opts = document.querySelectorAll('.quiz-option');
            opts.forEach(o => o.onclick = null);

            const q = examQuestions[currentQuizIndex];

            if (selectedIdx === q.answer) {
                document.getElementById(`opt-${selectedIdx}`).classList.add('correct');
                score += 20;
                displayFeedback("Correct!", true);
            } else {
                document.getElementById(`opt-${selectedIdx}`).classList.add('wrong');
                document.getElementById(`opt-${q.answer}`).classList.add('correct');
                score = Math.max(0, score - 10);
                displayFeedback("Incorrect", false);
            }
            updateScore();

            setTimeout(() => {
                alert(`Explanation: ${q.explanation}`);
                currentQuizIndex++;
                renderQuestion();
            }, 500);
        }

        // --- FLOW CONTROL ---

        function startGame() {
            try {
                modal.classList.add('hidden');
                
                document.getElementById('level-display').innerText = currentLevel + 1;
                document.getElementById('mode-name').innerText = levels[currentLevel].name;
                
                if (levels[currentLevel].mode === 'quiz') {
                    gridEl.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 50px; color: var(--accent); font-size: 2em; opacity:0.5;">THEORY MODE ACTIVE</div>';
                    cardArea.innerHTML = '<div style="color:#fff;">Calculating Theory Knowledge...</div>';
                    
                    modal.classList.remove('hidden');
                    document.getElementById('modal-title').innerText = "BOSS LEVEL";
                    document.getElementById('modal-desc').innerText = "Multiple Choice Exam Questions";
                    document.getElementById('modal-theory').innerHTML = "Answer correctly for bonus points. Wrong answers lose points.";
                    
                    quizArea.classList.remove('hidden');
                    actionBtn.classList.add('hidden'); 
                    startQuiz();
                } else {
                    initGrid();
                    showCard();
                }
            } catch (e) {
                alert("Error starting game: " + e.message + "\nCheck browser console for details.");
                console.error(e);
            }
        }

        function endLevel() {
            currentLevel++;
            if (currentLevel < levels.length) {
                document.getElementById('modal-title').innerText = `Level ${currentLevel} Complete`;
                document.getElementById('modal-desc').innerText = `Next up: ${levels[currentLevel].name}`;
                document.getElementById('modal-theory').innerHTML = `<strong>New Rule:</strong> ${levels[currentLevel].theory}`;
                
                currentCardIndex = 0;
                actionBtn.innerText = "Start Next Level";
                actionBtn.classList.remove('hidden');
                quizArea.classList.add('hidden');
                
                modal.classList.remove('hidden');
            }
        }

        // --- SAFE INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', function() {
            actionBtn.addEventListener('click', startGame);
        });

    </script>
</body>
</html>